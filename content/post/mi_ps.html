---
title: "Propensity Scores Analysis with Multiply Imputed Data"
author: "Megha Joshi"
date: 2020-06-23
categories: ["R"]
tags: ["propensity scores", "missing data", "multiple imputation" , "causal"]
output:
  html_document:
    toc: true
    toc_float: true
---



<p>Work in progress…</p>
<pre class="r"><code>library(tidyverse)
library(mice)
library(twang)
library(estimatr)
library(broom)</code></pre>
<div id="read-in-the-data" class="section level1">
<h1>Read in the data</h1>
<pre class="r"><code>hsls_dat &lt;- read_csv(&quot;https://raw.githubusercontent.com/meghapsimatrix/datasets/master/causal/HSLS09_incomplete.csv&quot;) %&gt;%
  mutate_if(is.character, as.factor) %&gt;%
  mutate_at(vars(repeated_grade, IEP, working_T3), as.factor)</code></pre>
<pre><code>## Parsed with column specification:
## cols(
##   .default = col_double(),
##   sex = col_character(),
##   race = col_character(),
##   language = col_character(),
##   locale = col_character(),
##   region = col_character()
## )</code></pre>
<pre><code>## See spec(...) for full column specifications.</code></pre>
<pre class="r"><code>glimpse(hsls_dat)</code></pre>
<pre><code>## Rows: 21,402
## Columns: 20
## $ sex            &lt;fct&gt; M, F, F, F, F, M, M, F, M, F, M, F, F, F, M, M, M, M, …
## $ race           &lt;fct&gt; White, White, Black, White, White, White, White, White…
## $ language       &lt;fct&gt; English, English, English, English, English, English, …
## $ repeated_grade &lt;fct&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, NA, 0, 0,…
## $ IEP            &lt;fct&gt; 0, 0, 0, NA, NA, 0, NA, 0, NA, NA, 0, NA, NA, 0, 0, 0,…
## $ locale         &lt;fct&gt; rural, rural, suburb, suburb, rural, town, town, city,…
## $ region         &lt;fct&gt; MW, NE, W, S, S, NE, S, NE, S, MW, S, S, S, MW, MW, MW…
## $ SES            &lt;dbl&gt; 1.5644, -0.3699, 1.2741, 0.5498, 1.0639, 1.5144, -0.31…
## $ math_identity  &lt;dbl&gt; 1.76, -0.57, -0.57, 0.60, 1.16, 0.00, 0.60, 1.76, 1.76…
## $ math_utility   &lt;dbl&gt; 1.31, 1.31, 0.27, -0.70, 1.31, -0.70, NA, -1.33, 1.31,…
## $ math_efficacy  &lt;dbl&gt; 0.95, 0.55, 0.68, 0.10, 1.23, -1.41, NA, 1.62, 1.34, 0…
## $ math_interest  &lt;dbl&gt; 0.12, NA, 0.86, 0.19, 2.08, -1.13, NA, -0.18, 1.35, -0…
## $ engagement     &lt;dbl&gt; -1.41, -0.20, 1.39, -0.20, 0.96, -0.20, 0.10, 0.71, -0…
## $ belonging      &lt;dbl&gt; 0.84, 0.05, 0.37, -0.04, -0.52, 0.45, 0.11, -0.29, -0.…
## $ expectations   &lt;dbl&gt; 8, 11, 10, 10, 10, 8, 11, 8, 8, 11, 8, 2, 11, 4, 6, 8,…
## $ climate        &lt;dbl&gt; 0.60, 0.32, -0.61, -2.14, NA, -0.32, -0.16, -0.36, 0.6…
## $ drop_status    &lt;dbl&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, …
## $ math_score_T1  &lt;dbl&gt; 0.8304, -0.2956, 1.2997, -0.1427, 0.7106, 0.3732, 0.23…
## $ math_score_T2  &lt;dbl&gt; 2.6606, 1.0097, 1.1852, NA, 0.9994, 1.9987, 1.6591, 1.…
## $ working_T3     &lt;fct&gt; 0, 1, 1, NA, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,…</code></pre>
</div>
<div id="multiple-imputation-using-mice" class="section level1">
<h1>Multiple imputation using <code>mice</code></h1>
<pre class="r"><code>system.time(temp_data &lt;- mice(hsls_dat, m = 10, maxit = 10, seed = 20200516))

save(temp_data, file = &quot;temp_data.RData&quot;)</code></pre>
</div>
<div id="long-format-and-propensity-score-model" class="section level1">
<h1>Long format and propensity score model</h1>
<pre class="r"><code>load(&quot;temp_data.RData&quot;)
imp_dat &lt;- complete(temp_data, action = &quot;long&quot;)

covs &lt;- imp_dat %&gt;%
  select(sex:climate, math_score_T1)

equation_ps &lt;- paste(&quot;drop_status ~ &quot;, paste(names(covs), collapse = &quot; + &quot;))
equation_ps</code></pre>
<pre><code>## [1] &quot;drop_status ~  sex + race + language + repeated_grade + IEP + locale + region + SES + math_identity + math_utility + math_efficacy + math_interest + engagement + belonging + expectations + climate + math_score_T1&quot;</code></pre>
</div>
<div id="function-to-estimate-propensity-scores" class="section level1">
<h1>Function to estimate propensity scores</h1>
<pre class="r"><code>estimate_ps &lt;- function(equation, dat){
  
  ps_model &lt;- glm(as.formula(equation), family = binomial, data = dat)
  
  dat &lt;- dat %&gt;%
    mutate(ps_logit = predict(ps_model, type = &quot;link&quot;),
           ps = predict(ps_model, type = &quot;response&quot;))
  
  return(dat)
  
}


imp_dat_ps &lt;- imp_dat %&gt;%
  group_by(.imp) %&gt;%
  do(estimate_ps(equation_ps, .)) %&gt;%
  ungroup()</code></pre>
</div>
<div id="estimating-weights-using-the-across-and-within-methods" class="section level1">
<h1>Estimating weights using the across and within methods</h1>
<p>Across method: Uses the average of the propensity scores across the imputed datasets to calculate weights.</p>
<p>Within method: Uses the propensity scores estimated within each imputed dataset to calculate weights.</p>
<pre class="r"><code>imp_dat_ps &lt;- imp_dat_ps %&gt;%
  group_by(.id) %&gt;%
  mutate(ps_across = mean(ps)) %&gt;%
  ungroup() %&gt;%
  mutate(att_wt_across = drop_status + (1 - drop_status) * ps_across/(1 - ps_across),
         att_wt_within = drop_status + (1 - drop_status) * ps/(1 - ps))


imp_dat_ps %&gt;%
  select(.imp, ps, ps_across, att_wt_across, att_wt_within)</code></pre>
<pre><code>## # A tibble: 214,020 x 5
##     .imp       ps ps_across att_wt_across att_wt_within
##    &lt;int&gt;    &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt;         &lt;dbl&gt;
##  1     1 0.00339   0.00330       0.00331       0.00340 
##  2     1 0.00989   0.0102        0.0103        0.00999 
##  3     1 0.00135   0.00131       0.00132       0.00135 
##  4     1 0.0119    0.0114        0.0115        0.0120  
##  5     1 0.00222   0.00246       0.00246       0.00222 
##  6     1 0.00289   0.00294       0.00295       0.00290 
##  7     1 0.0113    0.0101        0.0102        0.0114  
##  8     1 0.00347   0.00375       0.00377       0.00348 
##  9     1 0.00327   0.00276       0.00276       0.00328 
## 10     1 0.000667  0.000633      0.000633      0.000667
## # … with 214,010 more rows</code></pre>
</div>
<div id="estimate-att-for-across-and-within-methods" class="section level1">
<h1>Estimate ATT for across and within methods</h1>
<pre class="r"><code>estimate_ATT &lt;- function(equation, dat, wts){
  
  wts &lt;- dat %&gt;% pull({{wts}})
  
  model &lt;- lm_robust(as.formula(equation), data = dat, weights = wts)
  
  res &lt;- model %&gt;%
    tidy() %&gt;%
    filter(term == &quot;drop_status&quot;) %&gt;%
    select(term, estimate, se = std.error, dci_low = conf.low, ci_high = conf.high, df = df)
  
  return(res)
  
}</code></pre>
<pre class="r"><code>equation_ancova &lt;- paste(&quot;math_score_T2 ~ drop_status + &quot;, paste(names(covs), collapse = &quot; + &quot;))
equation_ancova</code></pre>
<pre><code>## [1] &quot;math_score_T2 ~ drop_status +  sex + race + language + repeated_grade + IEP + locale + region + SES + math_identity + math_utility + math_efficacy + math_interest + engagement + belonging + expectations + climate + math_score_T1&quot;</code></pre>
<pre class="r"><code>across_res &lt;- imp_dat_ps %&gt;%
  group_by(.imp) %&gt;%
  do(estimate_ATT(equation = equation_ancova, dat = ., wts = att_wt_across)) %&gt;%
  ungroup()

within_res &lt;- imp_dat_ps %&gt;%
  group_by(.imp) %&gt;%
  do(estimate_ATT(equation = equation_ancova, dat = ., wts = att_wt_within)) %&gt;%
  ungroup()</code></pre>
</div>
<div id="pool-the-results" class="section level1">
<h1>Pool the results</h1>
<pre class="r"><code>calc_pooled &lt;- function(dat, est, se, df){
  
  dat &lt;- dat %&gt;%
    mutate(est = dat %&gt;% pull({{est}}),
           se = dat %&gt;%pull({{se}}),
           df = dat %&gt;% pull({{df}}))
  
  pooled &lt;- dat %&gt;%
    summarize(m = n(),
              B = var(est),  # between imputation var
              beta_bar = mean(est), # mean of estimated reg coeffs
              V_bar = mean(se^2), # mean of var - hc corrected   within imp var
              eta_bar = mean(df)) %&gt;%   # mean of df
    mutate(
      
      V_total = V_bar + B * (m + 1) / m,  #between and within var est
      gamma = ((m + 1) / m) * B / V_total,  
      df_m = (m - 1) / gamma^2,
      df_obs = eta_bar * (eta_bar + 1) * (1 - gamma) / (eta_bar + 3),
      df = 1 / (1 / df_m + 1 / df_obs),
      
      # output
      se = sqrt(V_total),
      ci_lower = beta_bar - se * qt(0.975, df = df),
      ci_upper = beta_bar + se * qt(0.975, df = df)) %&gt;%
    
    select(est = beta_bar, se, df, ci_lower, ci_upper) 
  
  return(pooled)
  
}</code></pre>
<pre class="r"><code>across_pooled &lt;- calc_pooled(dat = across_res, est = estimate, se = se, df = df)
across_pooled</code></pre>
<pre><code>## # A tibble: 1 x 5
##      est     se    df ci_lower ci_upper
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1 -0.335 0.0379  93.8   -0.411   -0.260</code></pre>
<pre class="r"><code>within_pooled &lt;- calc_pooled(dat = within_res, est = estimate, se = se, df = df)
within_pooled</code></pre>
<pre><code>## # A tibble: 1 x 5
##      est     se    df ci_lower ci_upper
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1 -0.356 0.0410  50.0   -0.438   -0.273</code></pre>
</div>
